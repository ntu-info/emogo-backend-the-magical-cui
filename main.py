# main.py
import os
import io
import csv
import zipfile
from pathlib import Path
from fastapi import FastAPI, Request, Body
from typing import Optional
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, StreamingResponse
from motor.motor_asyncio import AsyncIOMotorClient
from fastapi.templating import Jinja2Templates
from pydantic import BaseModel
from datetime import datetime


MONGODB_URI = os.getenv("MONGODB_URI", "mongodb+srv://ann41422_db_user:12345testtest@cluster0.9l56haf.mongodb.net/")  # æœ¬æ©Ÿæ¸¬è©¦å¯ä»¥å…ˆå¯«æ­»ï¼ŒDeploy å†æ”¹æˆç’°å¢ƒè®Šæ•¸
DB_NAME = "emogo_db"

app = FastAPI()


templates = Jinja2Templates(directory="templates")


class EmoGoLog(BaseModel):
    ts: datetime
    mood: int
    lat: float
    lng: float
    videoname: str | None = None 



# 1. å•Ÿå‹•æ™‚é€£ç·š MongoDB

@app.get("/items/{item_id}")
def read_item(item_id: int, q: Optional[str] = None):
    return {"item_id": item_id, "q": q}

@app.on_event("startup")
async def startup_db_client():
    app.mongodb_client = AsyncIOMotorClient(MONGODB_URI)
    app.mongodb = app.mongodb_client[DB_NAME]

@app.on_event("shutdown")
async def shutdown_db_client():
    app.mongodb_client.close()

# 2. æ›è¼‰å½±ç‰‡è³‡æ–™å¤¾ï¼š/videos/... -> å°ˆæ¡ˆè£¡çš„ videos/ æª”æ¡ˆ
app.mount("/videos", StaticFiles(directory="videos"), name="videos")

# 3. ç°¡å–® health check
@app.get("/")
async def root():
    return {"message": "EmoGo backend is running"}

# 4. /exportï¼šå›ä¸‰ç¨®è³‡æ–™çš„ JSON

@app.get("/export_json")
async def export_data_json(request: Request):
    samples = await app.mongodb["samples_ts_rating_gps"].find().to_list(10000)

    base_url = str(request.base_url).rstrip("/")

    vlogs = []
    for s in samples:
        filename = s.get("video_filename")
        if not filename:
            continue
        video_url = f"{base_url}/videos/{filename}"
        vlogs.append({
            "id": s.get("id"),
            "ts": s.get("ts"),
            "video_filename": filename,
            "video_url": video_url,
        })

    sentiments = [
        {
            "id": s.get("id"),
            "ts": s.get("ts"),
            "mood": s.get("mood"),
        }
        for s in samples
    ]

    gps = [
        {
            "id": s.get("id"),
            "ts": s.get("ts"),
            "lat": s.get("lat"),
            "lng": s.get("lng"),
        }
        for s in samples
    ]

    return {"vlogs": vlogs, "sentiments": sentiments, "gps": gps}



@app.get("/export", response_class=HTMLResponse)
async def export(request: Request):
    docs = (
        await app.mongodb["samples_ts_rating_gps"]
        .find()
        .sort("ts", 1)
        .to_list(None)
    )

    rows = []
    # é€™è£¡ç”¨ enumerateï¼Œè‡ªå‹•çµ¦ 1, 2, 3, ...
    for idx, doc in enumerate(docs, start=1):
        ts_raw = doc.get("ts")
        ts_str = str(ts_raw).split(".")[0]

        lat = round(float(doc.get("lat", 0)), 4)
        lng = round(float(doc.get("lng", 0)), 4)

        filename = doc.get("videoname")
        file_url = f"/videos/{filename}" if filename else None

        rows.append(
            {
                "id": idx,  # ğŸ‘ˆ é€™è£¡ç”¨ enumerate çš„ idxï¼Œä¸å†è®€ doc.get("id")
                "timestamp": ts_str,
                "mood": doc.get("mood"),
                "lat": lat,
                "lng": lng,
                "filename": filename,
                "file_url": file_url,
            }
        )

    return templates.TemplateResponse(
        "export.html",
        {"request": request, "rows": rows},
    )


@app.get("/export-zip")
async def export_zip():
    # è®€å‡ºæ‰€æœ‰è³‡æ–™ï¼ˆè·Ÿ /export ä¸€æ¨£ï¼‰
    docs = (
        await app.mongodb["samples_ts_rating_gps"]   # â† æ›æˆä½ çš„ collection åç¨±
        .find()
        .sort("ts", 1)
        .to_list(None)
    )

    # å»ºä¸€å€‹è¨˜æ†¶é«”ä¸­çš„ä½å…ƒçµ„ç·©è¡å€ä¾†æ”¾ zip
    zip_buffer = io.BytesIO()

    with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_DEFLATED) as zf:
        # -------- 1) å…ˆå»ºç«‹ CSV æª”å…§å®¹ --------
        csv_buffer = io.StringIO()
        writer = csv.writer(csv_buffer)

        # CSV æ¬„ä½ï¼ˆé€™è£¡ä¸æ”¾ Download/Previewï¼‰
        writer.writerow(["ID", "Timestamp", "Mood", "Latitude", "Longitude", "Filename"])

        for doc in docs:
            ts_raw = doc.get("ts")
            ts_str = str(ts_raw).split(".")[0]  # å»æ‰å°æ•¸é»

            lat = round(float(doc.get("lat", 0)), 4)
            lng = round(float(doc.get("lng", 0)), 4)

            filename = doc.get("videoname")

            writer.writerow([
                doc.get("id"),
                ts_str,
                doc.get("mood"),
                lat,
                lng,
                filename,
            ])

        # æŠŠ CSV å¯«å…¥ zipï¼ˆæª”åå« emogo_export.csvï¼‰
        zf.writestr("emogo_export.csv", csv_buffer.getvalue())

        # -------- 2) å†æŠŠæ‰€æœ‰æœ‰å°æ‡‰æª”æ¡ˆçš„å½±ç‰‡å¡é€² zip --------
        videos_dir = Path("videos")
        for doc in docs:
            filename = doc.get("videoname")
            if not filename:
                continue

            video_path = videos_dir / filename
            if video_path.exists():
                # ç¬¬äºŒå€‹åƒæ•¸æ˜¯ zip è£¡é¢çš„è·¯å¾‘ï¼Œæ•´ç†ä¸€ä¸‹æ”¾åœ¨ videos/ åº•ä¸‹
                zf.write(video_path, arcname=f"videos/{filename}")
            # å¦‚æœå½±ç‰‡æª”ä¸å­˜åœ¨å°±ç•¥éï¼Œé¿å…æ•´åŒ…éŒ¯æ‰

    # æº–å‚™å¥½ zip å›å‚³
    zip_buffer.seek(0)
    headers = {
        "Content-Disposition": 'attachment; filename="emogo_package.zip"'
    }
    return StreamingResponse(
        zip_buffer,
        media_type="application/x-zip-compressed",
        headers=headers,
    )

@app.post("/api/log")
async def create_log(log: EmoGoLog = Body(...)):
    doc = {
        "ts": log.ts,
        "mood": log.mood,
        "lat": log.lat,
        "lng": log.lng,
        "videoname": log.videoname,
    }
    result = await app.mongodb["samples_ts_rating_gps"].insert_one(doc)
    return {"inserted_id": str(result.inserted_id)}

